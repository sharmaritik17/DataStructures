
# Linked List

- LinkedList donot have index based access
- Arrays have index based access

**Pros n Cons**

- Array give random access but LL dont. 
- Lesser storage required for arrays because ll also stores pointers
- insertions in between nodes is easy in LL whereas insertion in between positions of array is difficult

### Linked list structure

```cpp
class Node {
	public:
	int data;
	Node *next
};
```

**Time Complexity of Operations in LinkedList**

- Insertion 
	- At front O(1)
	- At end O(n) 
	- At Middle O(k) ( Addition after kth Node)
- Deletion
	- At front O(1)
	- At end O(n) ( If tail not present )
	- At Middle O(k) ( Addition after kth Node)

- Traversal
  	- O(n)

*Essential feature to know in the LL is head*

**Q - How to delete the complete list if we know the head??**
In Java just delete the head, but in C or C++ there is no auto garbage collection, we will iteratively delete the nodes

**Q - Find the value of nth node from first**
Just iterate from head till n iterations

## Assignment Questions 

**Q1 - Find the value of nth node from last**

*Approach 1*
(Use length of linked list)
1) Calculate the length of Linked List. Let the length be len.
2) Print the (len â€“ n + 1)th node from the beginning of the Linked List.

*Can we do it in single iteration?*

Double pointer concept : First pointer is used to store the address of the variable and second pointer used to store the address of the first pointer. If we wish to change the value of a variable by a function, we pass pointer to it. And if we wish to change value of a pointer (i. e., it should start pointing to something else), we pass pointer to a pointer.
One approach is to find length of LL as L, then . go to L - n + 1 th node


**Q- Reverse the LinkedList**

**Iteratively**

 ```java
 
Initialize three pointers prev as NULL, curr as head and next as NULL.
Iterate trough the linked list. In loop, do following.

// Before changing next of current,
// store next node
next = curr->next

// Now change next of current
// This is where actual reversing happens
curr->next = prev

// Move prev and curr one step forward
prev = curr
curr = next

```
