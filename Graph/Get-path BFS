
#include <bits/stdc++.h>
using namespace std;

#include  <bits/stdc++.h>
#define nul     NULL
#define hell    INT_MIN
#define hevn    INT_MAX
#define ll     long long
#define  z "\n"
#include <iostream>
#include <vector>
#include <climits>
#define ff first
#define ss second
using namespace std;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

vector<int>* getPathBFS(bool **edge, int n, int start, int end, bool* visited) {
	queue<int>pendingVertices;
	unordered_map<int, int> map;
	pendingVertices.push(start);
    visited[start]=1;
	bool pathFound = 0;

	while (pendingVertices.size() && !pathFound) {
		auto front = pendingVertices.front();
		pendingVertices.pop();

		for (int i = 0; i < n; i++) {
			if (!visited[i] && edge[i][front]) {
				map[i] = front;
                visited[i]=1;
				pendingVertices.push(i);
				if (end == i) {
					pathFound = 1;
					break;
				}
			}
		}
	}

	if (!pathFound)
		return NULL;

	vector<int> *output = new vector<int>();
	int current = end;
	output->push_back(end);

	while (current != start) {
		current = map[current];
		output->push_back(current);
	}
	return output;
}

int main() {
	int n, e;
	cin >> n >> e;
	bool **edges = new bool*[n];
	for (int i = 0; i < n; i++) {
		edges[i] = new bool[n];
		for (int j = 0; j < n; j++) {
			edges[i][j] = 0;
		}
	}


	//edges
	for (int i = 0; i < e; i++) {
		int f, s;
		cin >> f >> s;
		edges[f][s] = edges[s][f] = 1;
	}

	//visited array
	bool *visited = new bool[n];
	for (int i = 0; i < n; i++) {
		visited[i] = 0;
	}

	int start, end;
	cin >> start >> end;

	vector<int> *output = getPathBFS(edges, n, start, end, visited);

	if (output != NULL) {
		for (int i = 0; i < output->size(); i++) {
			cout << output->at(i) << " ";
		}
	}

	delete []visited;

	for (int i = 0; i < n; i++) {
		delete []edges[i];
	}

	delete []edges;
}


